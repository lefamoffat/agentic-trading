---
description: 
globs: 
alwaysApply: true
---
# Essential Coding Requirements

## 🚨 CRITICAL: NO MOCK VALUES IN PRODUCTION CODE
**ABSOLUTELY FORBIDDEN: Mock, simulated, fake, or placeholder values in production code**

### ZERO TOLERANCE POLICY - EXAMPLES OF FORBIDDEN CODE
- ❌ **NO** mock training metrics (`reward: 1000 + (step / total_steps) * 500`)
- ❌ **NO** simulated portfolio values (`portfolio_value = 10000 + fake_calculation`)
- ❌ **NO** placeholder calculations (`sharpe_ratio = min(2.0, fake_formula)`)
- ❌ **NO** hardcoded fake data (`win_rate = 0.6 + fake_progression`)
- ❌ **NO** "simulation" loops that generate fake training metrics
- ❌ **NO** TODO comments with mock implementations underneath
- ❌ **NO** "temporary" placeholder values
- ❌ **NO** hardcoded sample data (`const sampleData = [...]`)
- ❌ **NO** mock API responses in production components
- ❌ **NO** fake timestamps (`Date.now() + Math.random() * 1000`)
- ❌ **NO** placeholder user data (`{ name: "John Doe", email: "test@example.com" }`)
- ❌ **NO** dummy calculations (`profit = Math.random() * 1000`)
- ❌ **NO** static fallback values that bypass real data sources
- ❌ **NO** fake loading states with setTimeout delays
- ❌ **NO** placeholder error messages in production flows

### PRODUCTION CODE MUST BE REAL
Every piece of data, calculation, and logic in production modules must be:
- ✅ **CONNECTED TO REAL SOURCES**: Actual market data, real APIs, genuine calculations
- ✅ **COMPUTED FROM ACTUAL INPUTS**: Real trading results, actual broker responses
- ✅ **DERIVED FROM REAL OPERATIONS**: Authentic portfolio values, genuine performance metrics
- ✅ **SOURCED FROM REAL COMPONENTS**: Actual agents, real environments, live brokers

### WHAT TO DO INSTEAD
- ✅ **INTEGRATE REAL COMPONENTS**: Use actual agents, environments, brokers
- ✅ **REAL DATA FLOW**: Market data → Environment → Agent → Broker → Results
- ✅ **ACTUAL CALCULATIONS**: Compute real rewards, losses, portfolio values
- ✅ **GENUINE METRICS**: Track actual trading performance, not simulations
- ✅ **THROW ERRORS**: If real component not ready, throw NotImplementedError with specific message
- ✅ **CALL REAL APIS**: Connect to actual data sources and services
- ✅ **VALIDATE REAL DATA**: Process and validate authentic data from real sources

### IMPLEMENTATION PLAN FIRST
- ❌ **NEVER** add placeholder code "to get something working"
- ❌ **NEVER** implement mock data as a "temporary solution"
- ❌ **NEVER** add TODO comments with mock implementations
- ✅ **ALWAYS** address uncertainties in the implementation plan FIRST
- ✅ **ALWAYS** clarify requirements before writing code
- ✅ **ALWAYS** identify real data sources before implementation

### MOCK VALUES ONLY ALLOWED IN
- ✅ **Unit/Component Tests**: `mock_broker.return_value = fake_data`
- ✅ **Test Fixtures**: `@pytest.fixture def mock_price_data()`
- ✅ **Test Files**: Any file in `tests/` or `__tests__/` directories
- ✅ **Storybook Stories**: For UI component documentation
- ❌ **NEVER in src/ production modules**
- ❌ **NEVER in apps/ production code**
- ❌ **NEVER in production components**

### DETECTION AND PREVENTION
Common indicators of mock/placeholder code that MUST be eliminated:
- Comments containing "mock", "fake", "placeholder", "temporary", "TODO", "FIXME"
- Hardcoded arrays of sample data
- Math.random() calls for business logic
- Static timestamps or dates
- Hardcoded user/account information
- setTimeout() for fake loading delays
- Conditional logic that returns mock data

**This is a REAL TRADING SYSTEM, not a simulator or demo!**

## 🚨 CRITICAL: NO DUPLICATE FUNCTIONALITY
**ONE way to do each thing**

### FORBIDDEN
- ❌ Multiple functions doing the same thing
- ❌ Alternative APIs for the same functionality  
- ❌ "Legacy" and "new" versions coexisting
- ❌ Placeholder functions that throw NotImplementedError alongside working implementations

### REQUIRED
- ✅ Single canonical function per use case
- ✅ Clear deprecation and removal of old approaches
- ✅ Unified APIs that handle all variations internally

## Development Process
- **PLANNING FIRST**: Always outline implementation plan before making code changes
- **EXPLICIT CONFIRMATION**: Wait for user's explicit "go ahead" before creating/modifying files
- **NO ASSUMPTIONS**: Never proceed with implementation based on implied approval
- **ADDRESS UNCERTAINTIES FIRST**: Any open questions or unclear requirements MUST be resolved in the implementation plan BEFORE starting code changes
- **NO PLACEHOLDER CODE**: Never add mock/placeholder code as a "temporary solution" - address the real implementation requirement instead
- **REAL DATA SOURCES**: Identify and connect to actual data sources before implementation
- **NON-PRODUCTION SYSTEM**: This is a development system, not production. No "legacy migration" or "deprecation" phases needed
- **EXISTING PATTERNS**: Always reference actual config files in @/configs before making claims about configuration structure
- **CONVERSATION CONTEXT**: Read entire conversation history before making implementation plans

## Python Execution
- ALWAYS use `uv run` instead of `python` for all commands
- Example: `uv run main.py` not `python main.py`

## Import Standards
```python
# Standard library first
import pandas as pd
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field

# Project imports - ALWAYS absolute from src root
from src.utils.logger import get_logger
from src.types import SymbolType, BrokerType
# NEVER use relative imports like: from ...utils.logger
```

## Type Annotations
- REQUIRED for all public methods and class attributes
- Use `Optional[T]` instead of `Union[T, None]`
- Create project types in `src/types.py`

## Error Handling
- **See dedicated rule**: `.cursor/rules/patterns/error_handling.mdc`
- Create custom exceptions in `src/utils/exceptions.py`
- Always include descriptive error messages
- **NEVER return None/empty on errors** - raise exceptions instead

## Documentation (Google Style)
```python
def calculate_features(self, data: pd.DataFrame, symbol: Optional[str] = None) -> pd.DataFrame:
    """
    Calculate technical indicators and features.
    
    Args:
        data: OHLCV price data with required columns
        symbol: Trading symbol for context (optional)
        
    Returns:
        DataFrame with calculated features
        
    Raises:
        ValidationError: If data format is invalid
    """
```

## Code Completeness
- NO placeholders (`TODO`, `FIXME`)
- NO temporary workarounds or "hacky" solutions
- NO estimations where exact values can be computed
- NO hardcoded values (use config/params/env vars)
- **NO MOCK/SIMULATED VALUES IN PRODUCTION CODE** (see critical section above)
- If component not ready, use `raise NotImplementedError("Real [component] integration required")`

## 🚨 CRITICAL: NO QUICK STOP-GAP PATCHES
Temporary or compatibility "shims" that mask underlying issues are forbidden in
production modules. Always implement the **canonical**, long-term solution
instead of short-term work-arounds.

### REQUIRED
1. Remove deprecated or unmaintained dependencies rather than patching around
   them.
2. Align the codebase on a single, maintained library for each concern
   (e.g. `redis.asyncio` for asynchronous Redis access).
3. Keep implementation minimal and explicit – no fallback import chains that
   silently switch behaviour.

### EXCEPTION
Unit-test fixtures may still use lightweight stubs or shims, provided they are
scoped to `tests/` directories and clearly marked as such.

## Comments
- Must add long-term value and provide context-free understanding
- NEVER use comments to indicate recent changes: `# added new import`
- NEVER use temporary comments explaining current implementation details
- Comments must be TIMELESS - readable years from now without context
- BAD: `# gymnasium.spaces.Discrete.sample() returns numpy.int64, not Python int`
- GOOD: `# Handle both Python int and numpy integer types`
