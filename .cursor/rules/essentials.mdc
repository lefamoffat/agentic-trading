---
description: 
globs: 
alwaysApply: true
---
# Essential Coding Requirements

## 🚨 CRITICAL: NO MOCK VALUES IN PRODUCTION CODE
**ABSOLUTELY FORBIDDEN: Mock, simulated, or fake values in production code**

### ZERO TOLERANCE POLICY
- ❌ **NO** mock training metrics (`reward: 1000 + (step / total_steps) * 500`)
- ❌ **NO** simulated portfolio values (`portfolio_value = 10000 + fake_calculation`)
- ❌ **NO** placeholder calculations (`sharpe_ratio = min(2.0, fake_formula)`)
- ❌ **NO** hardcoded fake data (`win_rate = 0.6 + fake_progression`)
- ❌ **NO** "simulation" loops that generate fake training metrics
- ❌ **NO** TODO comments with mock implementations underneath
- ❌ **NO** "temporary" placeholder values

### WHAT TO DO INSTEAD
- ✅ **INTEGRATE REAL COMPONENTS**: Use actual agents, environments, brokers
- ✅ **REAL DATA FLOW**: Market data → Environment → Agent → Broker → Results
- ✅ **ACTUAL CALCULATIONS**: Compute real rewards, losses, portfolio values
- ✅ **GENUINE METRICS**: Track actual trading performance, not simulations
- ✅ **THROW ERRORS**: If real component not ready, throw NotImplementedError

### MOCK VALUES ONLY ALLOWED IN
- ✅ **Unit/Component Tests**: `mock_broker.return_value = fake_data`
- ✅ **Test Fixtures**: `@pytest.fixture def mock_price_data()`
- ❌ **NEVER in src/ production modules**

**This is a REAL TRADING SYSTEM, not a simulator!**

## 🚨 CRITICAL: NO DUPLICATE FUNCTIONALITY
**ONE way to do each thing**

### FORBIDDEN
- ❌ Multiple functions doing the same thing
- ❌ Alternative APIs for the same functionality  
- ❌ "Legacy" and "new" versions coexisting
- ❌ Placeholder functions that throw NotImplementedError alongside working implementations

### REQUIRED
- ✅ Single canonical function per use case
- ✅ Clear deprecation and removal of old approaches
- ✅ Unified APIs that handle all variations internally

## Development Process
- **PLANNING FIRST**: Always outline implementation plan before making code changes
- **EXPLICIT CONFIRMATION**: Wait for user's explicit "go ahead" before creating/modifying files
- **NO ASSUMPTIONS**: Never proceed with implementation based on implied approval
- **NON-PRODUCTION SYSTEM**: This is a development system, not production. No "legacy migration" or "deprecation" phases needed
- **EXISTING PATTERNS**: Always reference actual config files in @/configs before making claims about configuration structure
- **CONVERSATION CONTEXT**: Read entire conversation history before making implementation plans

## Python Execution
- ALWAYS use `uv run` instead of `python` for all commands
- Example: `uv run main.py` not `python main.py`

## Import Standards
```python
# Standard library first
import pandas as pd
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field

# Project imports - ALWAYS absolute from src root
from src.utils.logger import get_logger
from src.types import SymbolType, BrokerType
# NEVER use relative imports like: from ...utils.logger
```

## Type Annotations
- REQUIRED for all public methods and class attributes
- Use `Optional[T]` instead of `Union[T, None]`
- Create project types in `src/types.py`

## Error Handling
- **See dedicated rule**: `.cursor/rules/patterns/error_handling.mdc`
- Create custom exceptions in `src/utils/exceptions.py`
- Always include descriptive error messages
- **NEVER return None/empty on errors** - raise exceptions instead

## Documentation (Google Style)
```python
def calculate_features(self, data: pd.DataFrame, symbol: Optional[str] = None) -> pd.DataFrame:
    """
    Calculate technical indicators and features.
    
    Args:
        data: OHLCV price data with required columns
        symbol: Trading symbol for context (optional)
        
    Returns:
        DataFrame with calculated features
        
    Raises:
        ValidationError: If data format is invalid
    """
```

## Code Completeness
- NO placeholders (`TODO`, `FIXME`)
- NO temporary workarounds or "hacky" solutions
- NO estimations where exact values can be computed
- NO hardcoded values (use config/params/env vars)
- **NO MOCK/SIMULATED VALUES IN PRODUCTION CODE** (see critical section above)
- If component not ready, use `raise NotImplementedError("Real [component] integration required")`

## 🚨 CRITICAL: NO QUICK STOP-GAP PATCHES
Temporary or compatibility "shims" that mask underlying issues are forbidden in
production modules. Always implement the **canonical**, long-term solution
instead of short-term work-arounds.

### REQUIRED
1. Remove deprecated or unmaintained dependencies rather than patching around
   them.
2. Align the codebase on a single, maintained library for each concern
   (e.g. `redis.asyncio` for asynchronous Redis access).
3. Keep implementation minimal and explicit – no fallback import chains that
   silently switch behaviour.

### EXCEPTION
Unit-test fixtures may still use lightweight stubs or shims, provided they are
scoped to `tests/` directories and clearly marked as such.

## Comments
- Must add long-term value and provide context-free understanding
- NEVER use comments to indicate recent changes: `# added new import`
- NEVER use temporary comments explaining current implementation details
- Comments must be TIMELESS - readable years from now without context
- BAD: `# gymnasium.spaces.Discrete.sample() returns numpy.int64, not Python int`
- GOOD: `# Handle both Python int and numpy integer types`
